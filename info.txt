Math.pow(base, exponent)
де base - це число яка ми возводимо у ступінь
exponent - це беспосередньо ступінь
Math.pow(7, 2); // 49

Локальні змінні
Змінна, яка оголошена в функції доступна лише в тілі цієї функції.

function showMessage() {
  let message = "Привіт, я JavaScript!"; // локальна змінна

  alert( message );
}
showMessage(); // Привіт, я JavaScript!

alert( message ); // <-- Помилка! Змінна недоступна поза функцією

Зовнішні змінні
Функція може використовувати зовнішні змінні, наприклад:

let userName = 'Іван';

function showMessage() {
  let message = 'Привіт, ' + userName;
  alert(message);
}

showMessage(); // Привіт, Іван

Функція має повний доступ до зовнішньої змінної. Вона теж може її змінювати.

Зовнішня змінна використовується тоді, коли немає локальної.
Якщо всередині функції є змінна з таким самим ім’ям, то вона перекриває зовнішню. Наприклад, наступний код використовує локальну змінну userName. Зовнішня ігнорується.

let userName = 'Іван'; // оголошення зовнішньої змінної

function showMessage() {
  let userName = "Богдан"; // оголошення локальної змінної

  let message = 'Привіт, ' + userName; // Богдан
  alert(message);
}

// функція завжди віддасть перевагу локальним змінним
showMessage();

alert( userName ); // Іван, без змін, функція не змінила глобальну змінну
_____________
Рекурсивне мислення: спростити завдання та викликати функцією саму себе:

function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
Зверніть увагу, як рекурсивний варіант принципово відрізняється.

Коли pow(x, n) викликається, виконання розділяється на дві гілки:

              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
Якщо n == 1, то все тривіально. Це називається база рекурсії, оскільки вона негайно виробляє очевидний результат: pow(x, 1) дорівнює x.
Інакше ми можемо представляти pow(x, n) як x * pow(x, n - 1). У математиці можна написати xn = x * xn-1. Це називається рекурсивний крок: ми перетворюємо завдання на простішу дію (множення за допомогою x) та на простий виклик того ж завдання (pow з меншим n). Наступні кроки спрощують його далі і далі до n, що дорівнює 1.